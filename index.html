<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mini RimWorld - Rest System</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body { margin: 0; overflow: hidden; background-color: #1a202c; color: white; user-select: none; }
        canvas { display: block; }
        .pixel-font { font-family: 'Courier New', Courier, monospace; }
        
        /* è‡ªå®šä¹‰æ»šåŠ¨æ¡ */
        ::-webkit-scrollbar { width: 8px; }
        ::-webkit-scrollbar-track { background: #2d3748; }
        ::-webkit-scrollbar-thumb { background: #4a5568; border-radius: 4px; }
        ::-webkit-scrollbar-thumb:hover { background: #718096; }

        .panel {
            background: rgba(31, 41, 55, 0.95);
            border: 1px solid #4b5563;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.5);
        }

        .btn-action {
            transition: all 0.1s;
            border-bottom: 3px solid #00000040;
        }
        .btn-action:active {
            transform: translateY(2px);
            border-bottom: 0px solid transparent;
        }
        .btn-active {
            background-color: #3b82f6;
            color: white;
            border-color: #2563eb;
        }

        .pawn-card-wrapper {
            width: 64px;
            height: 70px; /* ç¨å¾®åŠ é«˜ä¸€ç‚¹å®¹çº³ä¸¤ä¸ªæ¡ */
            position: relative;
            cursor: pointer;
            pointer-events: auto;
            margin-right: 8px;
        }
        
        .pawn-card-inner {
            width: 100%;
            height: 100%;
            background-color: #2d3748;
            border: 2px solid #4a5568;
            border-radius: 0.375rem;
            transition: transform 0.1s, border-color 0.1s;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding-top: 0.2rem;
        }

        .pawn-card-wrapper:hover .pawn-card-inner {
            transform: scale(1.05);
            border-color: #a0aec0;
        }
        
        .pawn-card-inner.selected {
            border-color: #3b82f6;
            box-shadow: 0 0 10px #3b82f6;
        }

        /* çŠ¶æ€æ¡å®¹å™¨ */
        .bars-container {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 8px;
            display: flex;
            flex-direction: column;
            border-bottom-left-radius: 0.3rem;
            border-bottom-right-radius: 0.3rem;
            overflow: hidden;
        }

        .health-bar { height: 4px; background: #ef4444; width: 100%; }
        .health-fill { height: 100%; background: #22c55e; width: 100%; transition: width 0.3s; }
        
        .rest-bar { height: 4px; background: #1e3a8a; width: 100%; }
        .rest-fill { height: 100%; background: #60a5fa; width: 100%; transition: width 0.3s; }
        
        .cost-tooltip {
            position: absolute;
            bottom: 110%;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0,0,0,0.8);
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 10px;
            white-space: nowrap;
            display: none;
            z-index: 50;
        }
        .btn-action:hover .cost-tooltip { display: block; }
    </style>
</head>
<body class="pixel-font">

    <!-- é¡¶éƒ¨èµ„æºæ  -->
    <div class="absolute top-0 right-0 p-2 panel flex items-center space-x-6 z-10 rounded-bl-lg pointer-events-none">
        <div class="flex items-center text-green-400 font-bold pointer-events-auto" title="åº“å­˜é£Ÿç‰©">
            <span class="text-xl mr-2">ğŸ–</span> <span id="res-food">0</span>
        </div>
        <div class="flex items-center text-yellow-600 font-bold pointer-events-auto" title="åº“å­˜æœ¨æ">
            <span class="text-xl mr-2">ğŸªµ</span> <span id="res-wood">0</span>
        </div>
        <div class="flex items-center text-gray-400 font-bold pointer-events-auto" title="åº“å­˜çŸ³æ">
            <span class="text-xl mr-2">ğŸª¨</span> <span id="res-stone">0</span>
        </div>
        <div class="text-xs text-gray-500 border-l border-gray-600 pl-4 pointer-events-auto">
            Day <span id="game-day">1</span>
        </div>
    </div>

    <!-- é¡¶éƒ¨å¤´åƒæ  -->
    <div id="pawn-bar-container" class="absolute top-2 left-1/2 transform -translate-x-1/2 flex z-20" onmousedown="event.stopPropagation()"></div>

    <!-- å·¦ä¸‹è§’ä¿¡æ¯æ  -->
    <div id="info-panel" class="absolute bottom-4 left-4 w-64 panel p-4 rounded-lg z-10 hidden pointer-events-auto" onmousedown="event.stopPropagation()">
        <h3 class="text-lg font-bold text-yellow-400 mb-2 border-b border-gray-600 pb-1" id="info-title">ä¿¡æ¯</h3>
        <div id="info-content" class="text-sm text-gray-300 space-y-1"></div>
    </div>

    <!-- åº•éƒ¨æ“ä½œæ  -->
    <div class="absolute bottom-6 left-1/2 transform -translate-x-1/2 flex space-x-2 p-2 panel rounded-lg z-10 pointer-events-auto" onmousedown="event.stopPropagation()">
        <button class="btn-action px-3 py-2 bg-gray-700 hover:bg-gray-600 rounded text-xs font-bold flex flex-col items-center min-w-[60px] relative" onclick="setTool('select')" id="btn-select">
            <span class="text-lg">ğŸ‘†</span><span>é€‰æ‹©</span>
        </button>
        <button class="btn-action px-3 py-2 bg-gray-700 hover:bg-gray-600 rounded text-xs font-bold flex flex-col items-center min-w-[60px] relative" onclick="setTool('chop')" id="btn-chop">
            <span class="text-lg">ğŸª“</span><span>ä¼æœ¨</span>
        </button>
        <button class="btn-action px-3 py-2 bg-gray-700 hover:bg-gray-600 rounded text-xs font-bold flex flex-col items-center min-w-[60px] relative" onclick="setTool('mine')" id="btn-mine">
            <span class="text-lg">â›ï¸</span><span>é‡‡çŸ¿</span>
        </button>
        <button class="btn-action px-3 py-2 bg-gray-700 hover:bg-gray-600 rounded text-xs font-bold flex flex-col items-center min-w-[60px] relative" onclick="setTool('harvest')" id="btn-harvest">
            <span class="text-lg">ğŸ“</span><span>é‡‡é›†</span>
        </button>
        

         <button class="btn-action px-3 py-2 bg-red-900 hover:bg-red-800 rounded text-xs font-bold flex flex-col items-center min-w-[60px] relative" onclick="cancelJobTool()" id="btn-cancel">
            <span class="text-lg">ğŸš«</span><span>å–æ¶ˆ</span>
        </button>
    </div>

    <canvas id="gameCanvas"></canvas>

<script>
/**
 * Mini RimWorld - Rest & Sleep Update
 */

// --- é…ç½®ä¸å¸¸é‡ ---
const TILE_SIZE = 40;
const MAP_WIDTH = 50;
const MAP_HEIGHT = 50;
const COLORS = {
    GRASS: '#4ade80',
    GRASS_DARK: '#22c55e',
    DIRT: '#854d0e',
    WALL: '#57534e',
    WATER: '#3b82f6',
    ROCK: '#525252',
    TREE: '#14532d',
    BERRY: '#be123c',
    BLUEPRINT: 'rgba(59, 130, 246, 0.3)',
    BLUEPRINT_BORDER: '#3b82f6',
    BUILDING_PREVIEW_OK: 'rgba(59, 130, 246, 0.5)',
    BUILDING_PREVIEW_BAD: 'rgba(239, 68, 68, 0.5)'
};

const PAWN_NAMES = ["Alex", "Ben", "Cara", "Dave", "Eve", "Frank"];

const resources = {
    food: 0,
    wood: 0,
    stone: 0
};

const BUILDINGS = {
    // ä»“åº“å’Œå¸ç¯·å·²è¢«åˆ é™¤ï¼Œæ ¹æ®ç”¨æˆ·éœ€æ±‚ï¼Œèµ„æºç›´æ¥æ”¾åœ¨åœ°ä¸Šï¼Œå°äººåœ¨é‡å¤–è¿›é£Ÿå’Œç¡çœ 
};

let camera = { x: 0, y: 0, zoom: 1 };
let isDragging = false;
let lastMouse = { x: 0, y: 0 };
let currentTool = 'select';
let hoveredTile = { x: -1, y: -1 };
let selectedEntity = null;
let gameTime = 0;

// --- ç±»å®šä¹‰ ---

class Tile {
    constructor(x, y, type) {
        this.x = x; this.y = y; this.type = type; 
        this.buildingRef = null; 
        this.object = null; 
        this.designation = null; 
        this.items = []; 
        this.walkable = type !== 'water';
    }
}

class Building {
    constructor(type, x, y, isBlueprint = false) {
        this.id = Math.random().toString(36).substr(2, 9);
        this.type = type;
        this.x = x; this.y = y;
        this.data = BUILDINGS[type];
        this.isBlueprint = isBlueprint;
        this.progress = isBlueprint ? 0 : 100; 
        this.needed = isBlueprint ? { ...this.data.cost } : {};
        this.delivered = { wood: 0, stone: 0 }; 
        this.items = []; 
    }

    needsMaterial(type) {
        if (!this.isBlueprint) return false;
        return (this.delivered[type] || 0) < (this.needed[type] || 0);
    }

    addMaterial(type, amount) {
        if (!this.delivered[type]) this.delivered[type] = 0;
        this.delivered[type] += amount;
        return true; 
    }
    
    isReadyToBuild() {
        if (!this.isBlueprint) return false;
        for (let key in this.needed) {
            if ((this.delivered[key] || 0) < this.needed[key]) return false;
        }
        return this.progress < 100;
    }
}

class Pawn {
    constructor(x, y, name, id) {
        this.id = id;
        this.x = x; this.y = y;
        this.targetX = null; this.targetY = null;
        this.name = name;
        this.color = `hsl(${Math.random() * 360}, 60%, 50%)`;
        this.state = 'IDLE'; // IDLE, MOVING, WORKING, SLEEPING, PASSED_OUT
        this.job = null; 
        this.hunger = 100;
        this.rest = 100; // æ–°å¢ä¼‘æ¯åº¦
        this.carrying = null; 
    }

    update() {
        // è‡ªç„¶æ¶ˆè€—
        this.hunger -= 0.02;
        if (this.hunger < 0) this.hunger = 0;
        
        // ä¼‘æ¯åº¦æ¶ˆè€— (é†’ç€çš„æ—¶å€™)
        if (this.state !== 'SLEEPING' && this.state !== 'PASSED_OUT') {
            this.rest -= 0.01; // çº¦æ¯2ç§’é™1ç‚¹
        }

        // æ˜å¥æ£€æŸ¥
        if (this.rest <= 0 && this.state !== 'SLEEPING') {
            this.state = 'PASSED_OUT';
            this.job = null;
            this.targetX = null;
            this.targetY = null;
        }

        switch (this.state) {
            case 'IDLE':
                this.findJob();
                // é—²é€›
                if (!this.job && Math.random() < 0.01) {
                    this.setDestination(this.x + (Math.random() * 4 - 2), this.y + (Math.random() * 4 - 2));
                }
                break;
            case 'MOVING':
                this.move();
                break;
            case 'WORKING':
                this.doWork();
                break;
            case 'SLEEPING':
                this.doSleep();
                break;
            case 'PASSED_OUT':
                this.doPassedOut();
                break;
        }
    }

    findJob() {
        // 0. ç–²åŠ³æ£€æŸ¥ (æœ€é«˜ä¼˜å…ˆçº§)
        if (this.rest < 5) {
            // å¯»æ‰¾å¸ç¯·æˆ–åŸºåœ°
            const bed = findNearestBuilding(this.x, this.y, ['tent', 'base_camp']);
            if (bed) {
                this.job = { type: 'SLEEP', targetBuilding: bed };
                this.calculatePath(bed.x, bed.y);
                return;
            } else {
                // æ²¡æœ‰åºŠï¼Œåœ¨åŸåœ°ç¡è§‰
                this.job = { type: 'SLEEP_GROUND' };
                this.state = 'SLEEPING';
                showFloatingText(this.x, this.y, "Sleeping on ground", "#60a5fa");
                return;
            }
        }

        // 1. åƒé¥­
        if (this.hunger < 30) {
            const foodTile = findNearestItem(this, 'food');
            if (foodTile) {
                this.job = { type: 'EAT_ITEM', tile: foodTile };
                this.calculatePath(foodTile.x, foodTile.y);
                return;
            }
            const bushTile = findNearestObject(this, 'berry');
            if (bushTile) {
                this.job = { type: 'EAT_BUSH', tile: bushTile };
                this.calculatePath(bushTile.x, bushTile.y);
                return;
            }
        }

        // 2. å»ºé€ é€»è¾‘
        const blueprintNeedsMat = findBlueprintNeedsMaterial(this);
        if (blueprintNeedsMat) {
            const matType = blueprintNeedsMat.matType;
            const bp = blueprintNeedsMat.building;
            // å¯»æ‰¾åœ°ä¸Šçš„ææ–™
            const matTile = findNearestItem(this, matType);
            if (matTile) {
                 this.job = { type: 'HAUL_BUILD', targetBuilding: bp, tile: matTile, matType: matType };
                 this.calculatePath(matTile.x, matTile.y);
                 return;
            }
        }
        
        const blueprintReady = findBlueprintReadyToBuild(this);
        if (blueprintReady) {
            this.job = { type: 'CONSTRUCT', targetBuilding: blueprintReady };
            this.calculatePath(blueprintReady.x, blueprintReady.y);
            return;
        }

        // 3. æ¬è¿ (æš‚æ—¶åˆ é™¤ï¼Œå› ä¸ºæ²¡æœ‰ä»“åº“ã€‚èµ„æºç›´æ¥ç•™åœ¨åœ°ä¸Š)

        // 4. å·¥ä½œ
        const jobTile = findNearestJob(this);
        if (jobTile) {
            this.job = { type: jobTile.designation, tile: jobTile };
            this.calculatePath(jobTile.x, jobTile.y);
        }
    }

    setDestination(tx, ty) {
        tx = Math.max(0, Math.min(MAP_WIDTH - 1, Math.round(tx)));
        ty = Math.max(0, Math.min(MAP_HEIGHT - 1, Math.round(ty)));
        if (map[tx][ty].walkable && !map[tx][ty].buildingRef) {
             this.calculatePath(tx, ty);
        }
    }

    calculatePath(tx, ty) {
        this.targetX = tx;
        this.targetY = ty;
        this.state = 'MOVING';
    }

    move() {
        if (this.targetX === null) return;
        const dx = this.targetX - this.x;
        const dy = this.targetY - this.y;
        const dist = Math.sqrt(dx * dx + dy * dy);
        const speed = 0.08;

        if (dist < speed) {
            this.x = this.targetX;
            this.y = this.targetY;
            
            // ç¡çœ ä»»åŠ¡ç‰¹æ®Šå¤„ç†
            if (this.job && this.job.type === 'SLEEP') {
                // ç¨å¾®èµ°è¿›å»ºç­‘ä¸­å¿ƒä¸€ç‚¹
                this.x = this.job.targetBuilding.x + 0.5;
                this.y = this.job.targetBuilding.y + 0.5;
                this.state = 'SLEEPING';
                showFloatingText(this.x, this.y, "Zzz...", "#60a5fa");
                return;
            }

            // æ¬è¿ä»»åŠ¡ (åˆ†ä¸¤é˜¶æ®µï¼š1. èµ°åˆ°ææ–™å¤„å¹¶æ¡èµ· 2. èµ°åˆ°å»ºç­‘å¤„)
            if (this.job && this.job.type === 'HAUL_BUILD') {
                if (!this.carrying) {
                    // åˆ°è¾¾ææ–™æ‰€åœ¨æ ¼å­
                    const tile = this.job.tile;
                    const itemIdx = tile.items.findIndex(i => i.type === this.job.matType);
                    if (itemIdx >= 0) {
                        const amount = Math.min(10, tile.items[itemIdx].amount);
                        tile.items[itemIdx].amount -= amount;
                        if (tile.items[itemIdx].amount <= 0) tile.items.splice(itemIdx, 1);

                        // æ›´æ–°å…¨å±€èµ„æºè®¡æ•°
                        resources[this.job.matType] -= amount;

                        this.carrying = { type: this.job.matType, amount: amount };
                        this.targetX = this.job.targetBuilding.x + 0.5;
                        this.targetY = this.job.targetBuilding.y + 0.5;
                        this.state = 'MOVING';
                        showFloatingText(this.x, this.y, "Picked up " + this.job.matType, "white");
                    } else {
                        this.job = null;
                        this.state = 'IDLE';
                    }
                } else {
                    this.state = 'WORKING';
                    this.workTimer = 0;
                }
                return;
            }

            if (this.job && this.job.type === 'HAUL' && !this.carrying) {
                if (this.job.tile.items.length > 0) {
                    this.carrying = this.job.tile.items.pop(); 
                    this.targetX = this.job.targetBuilding.x + 0.5; 
                    this.targetY = this.job.targetBuilding.y + 0.5;
                    this.state = 'MOVING';
                } else {
                    this.job = null; 
                    this.state = 'IDLE';
                }
                return;
            }
            
            if (this.job && this.job.type === 'CONSTRUCT') {
                 this.state = 'WORKING';
                 this.workTimer = 0;
                 return;
            }

            if (this.job && this.job.tile && Math.abs(this.x - this.targetX) < 0.5 && Math.abs(this.y - this.targetY) < 0.5) {
                this.state = 'WORKING';
                this.workTimer = 0;
            } else {
                this.state = 'IDLE';
            }
        } else {
            this.x += (dx / dist) * speed;
            this.y += (dy / dist) * speed;
        }
    }

    doWork() {
        if (!this.job) { this.state = 'IDLE'; return; }
        this.workTimer++;
        
        let workDuration = 60;
        if (this.job.type === 'HAUL' || this.job.type === 'HAUL_BUILD') workDuration = 20;

        if (this.workTimer >= workDuration) {
            this.completeJob();
        }
    }

    doSleep() {
        // åœ¨åºŠä¸Š/å¸ç¯·é‡Œï¼Œæ¢å¤å¿«ï¼›åœ¨åœ°ä¸Šæ¢å¤æ…¢ä¸€äº›
        let recovery = 0.4;
        if (this.job && this.job.type === 'SLEEP_GROUND') {
            recovery = 0.15; // æ¯”åºŠä¸Šæ…¢ï¼Œä½†æ¯”æ˜å¥å¿«
        }
        this.rest += recovery;
        if (Math.random() < 0.05) showFloatingText(this.x, this.y, "Zzz", "#60a5fa");
        
        if (this.rest >= 100) {
            this.rest = 100;
            this.state = 'IDLE';
            this.job = null;
            showFloatingText(this.x, this.y, "Refreshed!", "#22c55e");
        }
    }

    doPassedOut() {
        // å€’åœ¨é‡å¤–ï¼Œæ¢å¤æ…¢
        this.rest += 0.05;
        if (Math.random() < 0.02) showFloatingText(this.x, this.y, "...", "gray");

        if (this.rest >= 30) { 
            // ç¨å¾®æ¢å¤ä¸€ç‚¹å°±ä¼šé†’æ¥ï¼Œä½†ä»ç„¶å¾ˆç´¯
            this.state = 'IDLE';
            showFloatingText(this.x, this.y, "Ugh...", "gray");
        }
    }

    completeJob() {
        if (this.job.type === 'HAUL_BUILD') {
            const bp = this.job.targetBuilding;
            if (bp.isBlueprint && this.carrying) {
                bp.addMaterial(this.carrying.type, this.carrying.amount);
                showFloatingText(this.x, this.y, `Add ${this.carrying.amount} ${this.carrying.type}`, "#3b82f6");
            }
            this.carrying = null;
        }
        else if (this.job.type === 'CONSTRUCT') {
            const bp = this.job.targetBuilding;
            if (bp.isBlueprint) {
                bp.progress += 20;
                showFloatingText(this.x, this.y, `${bp.progress}%`, "#10b981");
                if (bp.progress >= 100) {
                    bp.isBlueprint = false;
                    bp.progress = 100;
                    for(let i=0; i<bp.data.w; i++) {
                        for(let j=0; j<bp.data.h; j++) { map[bp.x+i][bp.y+j].walkable = false; }
                    }
                }
            }
        }
        else if (this.job.type === 'HAUL' && this.carrying) {
            // è™½ç„¶ç¦ç”¨äº† HAUL ä»»åŠ¡ï¼Œä½†ä¿ç•™é€»è¾‘ä»¥é˜²ä¸‡ä¸€
            dropItem(Math.round(this.x), Math.round(this.y), this.carrying.type, this.carrying.amount);
            this.carrying = null;
        }
        else if (this.job.type === 'EAT_BUSH') {
             this.hunger = 100;
             dropItem(this.job.tile.x, this.job.tile.y, 'food', 5);
             this.job.tile.object = null;
        } 
        else if (this.job.type === 'EAT_ITEM') {
            const foodIdx = this.job.tile.items.findIndex(i => i.type === 'food');
            if (foodIdx >= 0) {
                const amountConsumed = Math.min(5, this.job.tile.items[foodIdx].amount);
                this.job.tile.items[foodIdx].amount -= amountConsumed;
                if (this.job.tile.items[foodIdx].amount <= 0) this.job.tile.items.splice(foodIdx, 1);

                // æ›´æ–°å…¨å±€èµ„æºè®¡æ•°
                resources.food -= amountConsumed;
                this.hunger = 100;
                showFloatingText(this.x, this.y, "Ate food", "#22c55e");
            }
        }
        else if (this.job.type === 'chop') {
            this.job.tile.object = null; this.job.tile.designation = null;
            dropItem(this.job.tile.x, this.job.tile.y, 'wood', 15);
        } 
        else if (this.job.type === 'mine') {
            this.job.tile.object = null; this.job.tile.designation = null; this.job.tile.walkable = true;
            dropItem(this.job.tile.x, this.job.tile.y, 'stone', 8);
        } 
        else if (this.job.type === 'harvest') {
            this.job.tile.object = null; this.job.tile.designation = null;
            dropItem(this.job.tile.x, this.job.tile.y, 'food', 12);
        }

        this.job = null;
        this.state = 'IDLE';
        updateUI();
    }
}

// --- åˆå§‹åŒ–ä¸å…¨å±€å˜é‡ ---
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d', { alpha: false });
let map = [];
let pawns = [];
let buildings = [];
let particles = [];

function init() {
    resize();
    generateMap();
    const cx = Math.floor(MAP_WIDTH/2);
    const cy = Math.floor(MAP_HEIGHT/2);

    // åˆå§‹èµ„æºæ”¾åœ¨åœ°ä¸Š
    dropItem(cx, cy, 'food', 20);
    dropItem(cx, cy + 1, 'wood', 50);

    spawnPawns(3, cx, cy);
    updatePawnBar();
    camera.x = (cx * TILE_SIZE) - canvas.width / 2;
    camera.y = (cy * TILE_SIZE) - canvas.height / 2;
    requestAnimationFrame(loop);
}

function generateMap() {
    map = [];
    for (let x = 0; x < MAP_WIDTH; x++) {
        map[x] = [];
        for (let y = 0; y < MAP_HEIGHT; y++) {
            const t = new Tile(x, y, 'grass');
            if (Math.abs(x - MAP_WIDTH/2) > 4 || Math.abs(y - MAP_HEIGHT/2) > 4) {
                const rand = Math.random();
                if (rand < 0.15) t.object = 'tree';
                else if (rand < 0.18) { t.object = 'rock'; t.walkable = false; }
                else if (rand < 0.20) t.object = 'berry';
            }
            map[x][y] = t;
        }
    }
}

function spawnPawns(count, cx, cy) {
    for (let i = 0; i < count; i++) {
        let x, y;
        do {
            x = cx + Math.floor(Math.random() * 6 - 3);
            y = cy + Math.floor(Math.random() * 6 - 3);
        } while (!map[x][y].walkable || map[x][y].object || map[x][y].buildingRef);
        pawns.push(new Pawn(x, y, PAWN_NAMES[i], i));
    }
}

function placeBuilding(type, x, y, force=false) {
    const bDef = BUILDINGS[type];
    for(let i=0; i<bDef.w; i++) {
        for(let j=0; j<bDef.h; j++) {
            const t = map[x+i][y+j];
            if (!t.walkable || t.object || t.buildingRef) return false;
        }
    }
    const b = new Building(type, x, y, !force);
    buildings.push(b);
    for(let i=0; i<bDef.w; i++) {
        for(let j=0; j<bDef.h; j++) { map[x+i][y+j].buildingRef = b; map[x+i][y+j].walkable = false; }
    }
    updateUI();
    return true;
}

function dropItem(x, y, type, amount) {
    if (x < 0 || x >= MAP_WIDTH || y < 0 || y >= MAP_HEIGHT) return;
    const tile = map[x][y];
    const existing = tile.items.find(i => i.type === type);
    if (existing) existing.amount += amount;
    else tile.items.push({ type, amount });

    // å¢åŠ å…¨å±€èµ„æºè®¡æ•°
    if (resources[type] !== undefined) resources[type] += amount;
}

// --- æŸ¥æ‰¾é€»è¾‘ (AI) ---

function findBlueprintNeedsMaterial(pawn) {
    for(const b of buildings) {
        if (b.isBlueprint) {
            if (b.needsMaterial('wood')) return { building: b, matType: 'wood' };
            if (b.needsMaterial('stone')) return { building: b, matType: 'stone' };
        }
    }
    return null;
}

function findBlueprintReadyToBuild(pawn) {
    for(const b of buildings) {
        if (b.isReadyToBuild()) return b;
    }
    return null;
}

function findNearestJob(pawn) {
    let nearest = null; let minDist = Infinity;
    for (let x = 0; x < MAP_WIDTH; x++) {
        for (let y = 0; y < MAP_HEIGHT; y++) {
            const t = map[x][y];
            if (t.designation) {
                const isTaken = pawns.some(p => p !== pawn && p.job && p.job.tile === t);
                if (isTaken) continue;
                const dist = Math.hypot(pawn.x - x, pawn.y - y);
                if (dist < minDist) { minDist = dist; nearest = t; }
            }
        }
    }
    return nearest;
}

function findNearestHaulable(pawn) {
    let nearest = null; let minDist = Infinity;
    for (let x = 0; x < MAP_WIDTH; x++) {
        for (let y = 0; y < MAP_HEIGHT; y++) {
            const t = map[x][y];
            if (t.items.length > 0) {
                 const isTaken = pawns.some(p => p !== pawn && p.job && p.job.type === 'HAUL' && p.job.tile === t);
                 if (isTaken) continue;
                 const dist = Math.hypot(pawn.x - x, pawn.y - y);
                 if (dist < minDist) { minDist = dist; nearest = t; }
            }
        }
    }
    return nearest;
}

function findNearestItem(pawn, type) {
    let nearest = null; let minDist = Infinity;
    for (let x = 0; x < MAP_WIDTH; x++) {
        for (let y = 0; y < MAP_HEIGHT; y++) {
            const t = map[x][y];
            if (t.items.some(i => i.type === type)) {
                 const dist = Math.hypot(pawn.x - x, pawn.y - y);
                 if (dist < minDist) { minDist = dist; nearest = t; }
            }
        }
    }
    return nearest;
}

function findNearestObject(pawn, type) {
    let nearest = null; let minDist = Infinity;
    for (let x = 0; x < MAP_WIDTH; x++) {
        for (let y = 0; y < MAP_HEIGHT; y++) {
            const t = map[x][y];
            if (t.object === type) {
                const dist = Math.hypot(pawn.x - x, pawn.y - y);
                if (dist < minDist) { minDist = dist; nearest = t; }
            }
        }
    }
    return nearest;
}

function findNearestBuilding(px, py, types) {
    let nearest = null; let minDist = Infinity;
    for(const b of buildings) {
        if (!b.isBlueprint && types.includes(b.type)) {
            const dist = Math.hypot(px - b.x, py - b.y);
            if(dist < minDist) { minDist = dist; nearest = b; }
        }
    }
    return nearest;
}

function showFloatingText(x, y, text, color) {
    particles.push({ x: x, y: y, text: text, color: color, life: 60, offset: 0 });
}

// --- æ¸²æŸ“ ---

function loop() {
    gameTime++;
    update();
    draw();
    if (gameTime % 10 === 0) updateUI();
    requestAnimationFrame(loop);
}

function update() {
    pawns.forEach(p => p.update());
    for (let i = particles.length - 1; i >= 0; i--) {
        const p = particles[i];
        p.life--;
        p.offset += 0.02;
        if (p.life <= 0) particles.splice(i, 1);
    }
}

function draw() {
    ctx.fillStyle = '#1a202c';
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    const zoom = camera.zoom;
    const startX = Math.floor(camera.x / (TILE_SIZE * zoom));
    const startY = Math.floor(camera.y / (TILE_SIZE * zoom));
    const endX = startX + Math.ceil(canvas.width / (TILE_SIZE * zoom)) + 1;
    const endY = startY + Math.ceil(canvas.height / (TILE_SIZE * zoom)) + 1;

    for (let x = Math.max(0, startX); x < Math.min(MAP_WIDTH, endX); x++) {
        for (let y = Math.max(0, startY); y < Math.min(MAP_HEIGHT, endY); y++) {
            const t = map[x][y];
            const screenX = (x * TILE_SIZE * zoom) - camera.x;
            const screenY = (y * TILE_SIZE * zoom) - camera.y;
            const size = TILE_SIZE * zoom;

            ctx.fillStyle = (x + y) % 2 === 0 ? COLORS.GRASS : COLORS.GRASS_DARK;
            ctx.fillRect(screenX, screenY, size, size);

            if (t.items.length > 0) {
                t.items.forEach((item, idx) => {
                    let char = item.type === 'wood' ? 'ğŸªµ' : (item.type === 'stone' ? 'ğŸª¨' : 'ğŸ–');
                    ctx.font = `${size * 0.5}px Arial`;
                    ctx.textAlign = 'center';
                    ctx.fillText(char, screenX + size/2 + (idx*3), screenY + size/2 + (idx*3));
                    ctx.fillStyle = 'white';
                    ctx.font = `${size * 0.25}px Arial`;
                    ctx.fillText(item.amount, screenX + size/2 + 10, screenY + size/2 + 10);
                });
            }

            if (t.object) {
                ctx.font = `${size * 0.8}px Arial`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                let char = t.object === 'tree' ? 'ğŸŒ²' : (t.object === 'rock' ? 'ğŸª¨' : 'ğŸ“');
                ctx.fillText(char, screenX + size/2, screenY + size/2);
            }

            if (t.designation) {
                ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
                ctx.fillRect(screenX, screenY, size, size);
                let icon = t.designation === 'chop' ? 'ğŸª“' : (t.designation === 'mine' ? 'â›ï¸' : 'ğŸ“');
                ctx.fillStyle = 'white';
                ctx.font = `${size * 0.4}px Arial`;
                ctx.fillText(icon, screenX + size/2, screenY + size/2);
            }
        }
    }

    buildings.forEach(b => {
        const screenX = (b.x * TILE_SIZE * zoom) - camera.x;
        const screenY = (b.y * TILE_SIZE * zoom) - camera.y;
        const width = b.data.w * TILE_SIZE * zoom;
        const height = b.data.h * TILE_SIZE * zoom;

        if (b.isBlueprint) {
            ctx.fillStyle = COLORS.BLUEPRINT;
            ctx.fillRect(screenX + 2, screenY + 2, width - 4, height - 4);
            ctx.strokeStyle = COLORS.BLUEPRINT_BORDER;
            ctx.lineWidth = 2;
            ctx.setLineDash([5, 5]);
            ctx.strokeRect(screenX + 2, screenY + 2, width - 4, height - 4);
            ctx.setLineDash([]);
            
            ctx.fillStyle = '#333';
            ctx.fillRect(screenX + 5, screenY + height - 15, width - 10, 5);
            ctx.fillStyle = '#3b82f6';
            ctx.fillRect(screenX + 5, screenY + height - 15, (width - 10) * (b.progress/100), 5);

            ctx.fillStyle = 'white';
            ctx.font = `${10 * zoom}px Arial`;
            ctx.textAlign = 'center';
            let statusText = `${b.delivered.wood||0}/${b.needed.wood||0}`;
            ctx.fillText(statusText, screenX + width/2, screenY + height/2);

        } else {
            ctx.fillStyle = b.data.color;
            ctx.fillRect(screenX + 5, screenY + 5, width - 10, height - 10);
            ctx.lineWidth = 4 * zoom;
            ctx.strokeStyle = '#333';
            ctx.strokeRect(screenX + 5, screenY + 5, width - 10, height - 10);
            
            ctx.font = `${width * 0.5}px Arial`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillStyle = 'white';
            ctx.fillText(b.data.symbol, screenX + width/2, screenY + height/2);
            
            if (selectedEntity === b) {
                ctx.strokeStyle = '#facc15';
                ctx.lineWidth = 3;
                ctx.strokeRect(screenX, screenY, width, height);
            }
        }
    });

    if (hoveredTile.x >= 0 && (currentTool === 'build_warehouse' || currentTool === 'build_tent')) {
        const bType = currentTool.replace('build_', '');
        const bDef = BUILDINGS[bType];
        const screenX = (hoveredTile.x * TILE_SIZE * zoom) - camera.x;
        const screenY = (hoveredTile.y * TILE_SIZE * zoom) - camera.y;
        const w = bDef.w * TILE_SIZE * zoom;
        const h = bDef.h * TILE_SIZE * zoom;
        let canBuild = true;
        if (hoveredTile.x + bDef.w > MAP_WIDTH || hoveredTile.y + bDef.h > MAP_HEIGHT) canBuild = false;
        else {
            for(let i=0; i<bDef.w; i++) {
                for(let j=0; j<bDef.h; j++) {
                    const t = map[hoveredTile.x+i][hoveredTile.y+j];
                    if (!t.walkable || t.object || t.buildingRef) canBuild = false;
                }
            }
        }
        ctx.fillStyle = canBuild ? COLORS.BUILDING_PREVIEW_OK : COLORS.BUILDING_PREVIEW_BAD;
        ctx.fillRect(screenX, screenY, w, h);
    }

    pawns.forEach(p => {
        const screenX = (p.x * TILE_SIZE * zoom) - camera.x;
        const screenY = (p.y * TILE_SIZE * zoom) - camera.y;
        const size = TILE_SIZE * zoom;

        // å¦‚æœåœ¨ç¡è§‰ï¼Œä¸ç”»äººï¼Œæˆ–è€…ç”»ä¸ªåŠé€æ˜çš„
        if (p.state === 'SLEEPING') {
            // ç®€å•ä¸ç”»ï¼Œæˆ–è€…åªç”»åå­—
            ctx.fillStyle = 'rgba(255,255,255,0.5)';
            ctx.font = `bold ${size * 0.3}px Arial`;
            ctx.textAlign = 'center';
            ctx.fillText("Zzz", screenX + size/2, screenY);
        } else {
            // æ­£å¸¸ç»˜åˆ¶
            ctx.fillStyle = p.color;
            ctx.beginPath();
            
            if (p.state === 'PASSED_OUT') {
                // å€’ä¸‹ï¼šç”»ä¸ªæ¨ªç€çš„æ¤­åœ†
                 ctx.ellipse(screenX + size/2, screenY + size/2 + size*0.2, size * 0.4, size * 0.2, 0, 0, Math.PI * 2);
            } else {
                 ctx.arc(screenX + size/2, screenY + size/2, size * 0.4, 0, Math.PI * 2);
            }
            
            ctx.fill();
            ctx.lineWidth = 2;
            ctx.strokeStyle = '#222';
            ctx.stroke();

            ctx.fillStyle = 'white';
            ctx.font = `bold ${size * 0.3}px Arial`;
            ctx.textAlign = 'center';
            ctx.fillText(p.name, screenX + size/2, screenY - size * 0.2);

            if (p.carrying) {
                let char = p.carrying.type === 'wood' ? 'ğŸªµ' : 'ğŸ“¦';
                ctx.font = `${size * 0.4}px Arial`;
                ctx.fillText(char, screenX + size, screenY + size);
            }
            
            if (p.state === 'PASSED_OUT') {
                ctx.fillStyle = '#ef4444';
                ctx.font = `bold ${size * 0.3}px Arial`;
                ctx.fillText("KO", screenX + size/2, screenY);
            }
        }

        if (selectedEntity === p) {
            ctx.strokeStyle = '#3b82f6';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.arc(screenX + size/2, screenY + size/2, size * 0.6, 0, Math.PI * 2);
            ctx.stroke();
        }
    });
    
    if (selectedEntity instanceof Tile) {
        const screenX = (selectedEntity.x * TILE_SIZE * zoom) - camera.x;
        const screenY = (selectedEntity.y * TILE_SIZE * zoom) - camera.y;
        ctx.strokeStyle = '#facc15';
        ctx.lineWidth = 3;
        ctx.strokeRect(screenX, screenY, TILE_SIZE*zoom, TILE_SIZE*zoom);
    }

    particles.forEach(p => {
        const screenX = (p.x * TILE_SIZE * zoom) - camera.x;
        const screenY = ((p.y - p.offset) * TILE_SIZE * zoom) - camera.y;
        ctx.fillStyle = p.color;
        ctx.shadowColor = 'black';
        ctx.shadowBlur = 2;
        ctx.font = `bold ${14 * zoom}px Arial`;
        ctx.fillText(p.text, screenX + TILE_SIZE/2, screenY);
        ctx.shadowBlur = 0;
    });
}

// --- UI æ¸²æŸ“ ---

function updatePawnBar() {
    const container = document.getElementById('pawn-bar-container');
    
    pawns.forEach(p => {
        let wrapper = document.getElementById(`pawn-wrapper-${p.id}`);
        
        if (!wrapper) {
            wrapper = document.createElement('div');
            wrapper.id = `pawn-wrapper-${p.id}`;
            wrapper.className = 'pawn-card-wrapper';
            wrapper.onmousedown = (e) => { e.stopPropagation(); };
            wrapper.onclick = (e) => { e.stopPropagation(); selectPawn(p); };
            wrapper.ondblclick = (e) => { e.stopPropagation(); selectPawn(p); camera.zoom = 1.5; };
            
            wrapper.innerHTML = `
                <div class="pawn-card-inner" id="pawn-inner-${p.id}">
                    <div style="width:24px; height:24px; border-radius:50%; background-color:${p.color}; border:2px solid rgba(0,0,0,0.5);"></div>
                    <div class="text-[10px] font-bold mt-1 text-gray-200">${p.name}</div>
                    <div class="text-[9px] text-gray-400" id="pawn-status-${p.id}">Idle</div>
                    <div class="bars-container">
                        <div class="health-bar"><div class="health-fill" id="pawn-health-${p.id}"></div></div>
                        <div class="rest-bar"><div class="rest-fill" id="pawn-rest-${p.id}"></div></div>
                    </div>
                </div>
            `;
            container.appendChild(wrapper);
        }
        
        const inner = document.getElementById(`pawn-inner-${p.id}`);
        const statusDiv = document.getElementById(`pawn-status-${p.id}`);
        const healthFill = document.getElementById(`pawn-health-${p.id}`);
        const restFill = document.getElementById(`pawn-rest-${p.id}`);
        
        if (selectedEntity === p) inner.classList.add('selected');
        else inner.classList.remove('selected');
        
        let statusText = 'Idle';
        if (p.state === 'PASSED_OUT') statusText = 'KO!';
        else if (p.state === 'SLEEPING') statusText = 'Sleep';
        else if (p.job) {
            if (p.job.type.includes('HAUL')) statusText = 'Haul';
            else if (p.job.type === 'CONSTRUCT') statusText = 'Build';
            else if (['chop','mine'].includes(p.job.type)) statusText = 'Mine';
            else if (['EAT_ITEM','EAT_BUSH'].includes(p.job.type)) statusText = 'Eat';
        }
        statusDiv.innerText = statusText;
        
        healthFill.style.width = `${p.hunger}%`;
        healthFill.style.backgroundColor = p.hunger < 30 ? '#ef4444' : '#22c55e';

        restFill.style.width = `${p.rest}%`;
        // ç–²åŠ³æ—¶æ¡å˜çº¢æç¤º
        restFill.style.backgroundColor = p.rest < 20 ? '#a855f7' : '#60a5fa';
    });
}

function selectPawn(pawn) {
    selectedEntity = pawn;
    camera.x = (pawn.x * TILE_SIZE * camera.zoom) - canvas.width / 2;
    camera.y = (pawn.y * TILE_SIZE * camera.zoom) - canvas.height / 2;
    updatePawnBar();
    updateInfoPanel();
}

function updateUI() {
    // ç°åœ¨èµ„æºé€šè¿‡ dropItem å’Œ é‡‡é›†/æ¶ˆè€—é€»è¾‘å®æ—¶æ›´æ–°ï¼Œæ— éœ€æ‰«æå…¨å›¾
    document.getElementById('res-food').innerText = resources.food;
    document.getElementById('res-wood').innerText = resources.wood;
    document.getElementById('res-stone').innerText = resources.stone;
    updatePawnBar();
    if (selectedEntity) updateInfoPanel();
}

function setTool(tool) {
    currentTool = tool;
    document.querySelectorAll('.btn-action').forEach(b => b.classList.remove('btn-active'));
    const btn = document.getElementById(`btn-${tool}`);
    if (btn) btn.classList.add('btn-active');
    selectedEntity = null;
    document.getElementById('info-panel').classList.add('hidden');
    updatePawnBar();
}

function cancelJobTool() { setTool('cancel'); }

function handleInteraction(x, y) {
    if (x < 0 || y < 0 || x >= MAP_WIDTH || y >= MAP_HEIGHT) return;
    const tile = map[x][y];

    if (currentTool === 'build_warehouse') { placeBuilding('warehouse', x, y); return; }
    if (currentTool === 'build_tent') { placeBuilding('tent', x, y); return; }

    if (currentTool === 'select') {
        const pawn = pawns.find(p => Math.round(p.x) === x && Math.round(p.y) === y);
        if (pawn) { selectPawn(pawn); return; }
        if (tile.buildingRef) { selectedEntity = tile.buildingRef; updatePawnBar(); updateInfoPanel(); return; }
        selectedEntity = tile;
        updatePawnBar(); updateInfoPanel();
    } 
    else if (currentTool === 'chop') { if (tile.object === 'tree') tile.designation = 'chop'; } 
    else if (currentTool === 'mine') { if (tile.object === 'rock') tile.designation = 'mine'; } 
    else if (currentTool === 'harvest') { if (tile.object === 'berry') tile.designation = 'harvest'; }
    else if (currentTool === 'cancel') { tile.designation = null; }
}

function updateInfoPanel() {
    const panel = document.getElementById('info-panel');
    const title = document.getElementById('info-title');
    const content = document.getElementById('info-content');
    
    if (!selectedEntity) { panel.classList.add('hidden'); return; }
    panel.classList.remove('hidden');

    if (selectedEntity instanceof Pawn) {
        title.innerText = `Colonist: ${selectedEntity.name}`;
        content.innerHTML = `
            <div>State: ${selectedEntity.state}</div>
            <div>Hunger: ${selectedEntity.hunger.toFixed(0)}/100</div>
            <div>Rest: ${selectedEntity.rest.toFixed(0)}/100</div>
            <div>Job: ${selectedEntity.job ? selectedEntity.job.type : 'None'}</div>
        `;
    } else if (selectedEntity instanceof Building) {
        const b = selectedEntity;
        title.innerText = b.isBlueprint ? `Blueprint: ${b.data.name}` : `Building: ${b.data.name}`;
        if (b.isBlueprint) {
            content.innerHTML = `
                <div class="text-blue-400">Under Construction</div>
                <div>Progress: ${b.progress}%</div>
                <div>Mat: ${b.delivered.wood||0}/${b.needed.wood||0} Wood</div>
            `;
        } else {
             content.innerHTML = `
                <div class="text-green-400">Operational</div>
                <div>Use for Sleeping</div>
            `;
        }
    } else if (selectedEntity instanceof Tile) {
        title.innerText = `Tile (${selectedEntity.x}, ${selectedEntity.y})`;
        let itemsHtml = selectedEntity.items.map(i => `${i.amount} ${i.type}`).join(', ');
        content.innerHTML = `
            <div>Type: ${selectedEntity.type}</div>
            <div>Items: ${itemsHtml || '-'}</div>
        `;
    }
}

canvas.addEventListener('mousedown', (e) => {
    if (e.target !== canvas) return;
    if (e.button === 0) { 
        isDragging = true;
        lastMouse = { x: e.clientX, y: e.clientY };
        const rect = canvas.getBoundingClientRect();
        const worldX = (e.clientX - rect.left + camera.x) / camera.zoom;
        const worldY = (e.clientY - rect.top + camera.y) / camera.zoom;
        const tileX = Math.floor(worldX / TILE_SIZE);
        const tileY = Math.floor(worldY / TILE_SIZE);
        handleInteraction(tileX, tileY);
    }
});
canvas.addEventListener('mousemove', (e) => {
    const rect = canvas.getBoundingClientRect();
    const mouseX = e.clientX - rect.left;
    const mouseY = e.clientY - rect.top;
    const worldX = (mouseX + camera.x) / camera.zoom;
    const worldY = (mouseY + camera.y) / camera.zoom;
    hoveredTile = { x: Math.floor(worldX / TILE_SIZE), y: Math.floor(worldY / TILE_SIZE) };
    if (e.altKey && isDragging) {
        camera.x -= (e.clientX - lastMouse.x);
        camera.y -= (e.clientY - lastMouse.y);
        lastMouse = { x: e.clientX, y: e.clientY };
    } else if (isDragging && currentTool !== 'select' && !currentTool.startsWith('build_')) {
        handleInteraction(hoveredTile.x, hoveredTile.y);
    }
});
canvas.addEventListener('mouseup', () => { isDragging = false; });
canvas.addEventListener('wheel', (e) => {
    e.preventDefault();
    const zoomSpeed = 0.1;
    if (e.deltaY < 0) camera.zoom = Math.min(camera.zoom + zoomSpeed, 3);
    else camera.zoom = Math.max(camera.zoom - zoomSpeed, 0.5);
});
window.addEventListener('resize', resize);
window.addEventListener('keydown', (e) => { if (e.key === 'Alt') document.body.style.cursor = 'move'; });
window.addEventListener('keyup', (e) => { if (e.key === 'Alt') document.body.style.cursor = 'default'; });
function resize() { canvas.width = window.innerWidth; canvas.height = window.innerHeight; }

setTool('select');
init();

</script>
</body>
</html>